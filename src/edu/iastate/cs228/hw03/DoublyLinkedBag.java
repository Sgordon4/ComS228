package edu.iastate.cs228.hw03;/**   A class of bags whose entries are stored in a chain of doubly linked nodes.   @author	   Sean Gordon    */public class DoublyLinkedBag<T> implements BagInterface<T>{	private DoublyLinkedNode firstNode;       // Reference to first node	private int numberOfEntries;	public DoublyLinkedBag()	{		firstNode = null;		numberOfEntries = 0;	} // end default constructor	public boolean add(T newEntry)	{		// Add to beginning of chain:		DoublyLinkedNode newNode = new DoublyLinkedNode(newEntry);		newNode.next = firstNode; 		// Make new node reference rest of chain		// (firstNode is null if chain is empty)        		if(firstNode != null) 			//If chain is not empty, 			firstNode.prev = newNode;	// links current first node backward to new first node		firstNode = newNode;      		// Sets 'first node' reference to the new node		numberOfEntries++;			return true;	} // end add	public T[] toArray()	{		// The cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] result = (T[])new Object[numberOfEntries]; // Unchecked cast		int index = 0;		DoublyLinkedNode currentNode = firstNode;		while ((index < numberOfEntries) && (currentNode != null))		{			result[index] = currentNode.data;			index++;			currentNode = currentNode.next;		} // end while		return result;	} // end toArray	public boolean isEmpty() 	{		return numberOfEntries == 0;	} // end isEmpty	public int getCurrentSize() 	{		return numberOfEntries;	} // end getCurrentSize	public int getFrequencyOf(T anEntry) 	{		int frequency = 0;		int counter = 0;		DoublyLinkedNode currentNode = firstNode;		while ((counter < numberOfEntries) && (currentNode != null))		{			if (anEntry.equals(currentNode.data))			{				frequency++;			} // end if			counter++;			currentNode = currentNode.next;		} // end while		return frequency;	} // end getFrequencyOf	public boolean contains(T anEntry)	{		boolean found = false;		DoublyLinkedNode currentNode = firstNode;		while (!found && (currentNode != null))		{			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		} // end while			return found;	} // end contains	public void clear() 	{		while (!isEmpty()) 		// Would it be more effective to set 'firstNode' to null			remove();			// and let the garbage collector have at it?	} // end clear	public T remove()	{		T result = null;		if (firstNode != null)		{			result = firstNode.data; 	// Save data of node for return			firstNode = firstNode.next; // Remove first node from chain			firstNode.prev = null;			numberOfEntries--;		} // end if		return result;					// Return data of removed node	} // end remove	private DoublyLinkedNode getReferenceTo(T anEntry)		//Helper method for remove	{		boolean found = false;		DoublyLinkedNode currentNode = firstNode;		while (!found && (currentNode != null))		{			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		} // end while		return currentNode;	} // end getReferenceTo	public boolean remove(T anEntry) 	{		boolean result = false;		DoublyLinkedNode nodeN = getReferenceTo(anEntry);		if (nodeN != null)		{			nodeN.data = firstNode.data; // Replace located entry with entry in first node			firstNode = firstNode.next;  // Remove first node			firstNode.prev = null;			numberOfEntries--;			result = true;		} // end if		return result;	} // end remove	public T replace(T replacement)	{		if(this.getCurrentSize() != 0) {			T replaced = this.firstNode.data;			this.firstNode.data = replacement;			return replaced;		}		return null;	}	public void removeEvery(T anEntry)	{		int frequency = this.getFrequencyOf(anEntry);		for(int i = 0; i < frequency; i++) {			remove(anEntry);			//If need to fill, replace this with the item at end of bag		}	}	public BagInterface<T> difference(BagInterface<T> anotherBag){		//Helper method for equals		BagInterface<T> difference = new DoublyLinkedBag<T>();		DoublyLinkedNode node = this.firstNode;		int frequency;		for(int i = 0; i < this.getCurrentSize(); i++) {			if(!difference.contains(node.data)) {	//Checks if the item has already been added to our new bag				//Finds the number of this specific item that don't match up between bags				frequency = Math.abs(this.getFrequencyOf(node.data) - anotherBag.getFrequencyOf(node.data));					for(int a = 0; a < frequency; a++) {					difference.add(node.data);				}			}			node = node.next;		}		return difference;	}	/**	 Override the equals method of Object class so that it returns true when the contents of two DoublyLinkedBags are same. Note that two equal DoublyLinkedBags contain the same number of entries, and each entry occurs in each DoublyLinkedBag the same number of times. I.e., the elements in two do not need to be in exact same location.	 Before checking the contents inside this method make sure that the passed in object is not null, is of the same runtime class, and the lengths are same. If any of these fail you can return false. Otherwise, you base your return results on contents. (At the start you can also do the quick check if both refer to the same object in memory.)	 	 */	@Override	@SuppressWarnings("unchecked")	public boolean equals(Object obj)	{		//obj has to pass instanceof test, so we can cast		if(obj != null && obj instanceof DoublyLinkedBag && (this.getCurrentSize() == ((DoublyLinkedBag<T>)obj).getCurrentSize())) {			if(this.difference((DoublyLinkedBag<T>)obj) == null)				return true;		}		return false;	}	/**	 Returns String representation of the items in this bag.	 For example, it would return [A, B, C] if bag had three Strings "A", "B", and "C".	 @return String representation of items in this bag enclosed in square brackets, separated by comma and a single space (see example above). You can rely on the fact that items' proper toString method was implemented. In this method ONLY if you need to you can use String class's methods. Also, ONLY in this method you can use fully qualified name for StringBuffer class, and use all of its methods.	 */	@Override	public String toString()	{		String ret = "[";					// I'm using String. There is legitimately no point in not using it.		DoublyLinkedNode current = firstNode;		while(current != null) {			ret += current.data;			ret += ", ";		}		ret += "]";		return ret; 	// Returns [] if list empty	}	// A class of nodes for a chain of doubly linked nodes.	private class DoublyLinkedNode	{		private T	data;					// Entry in bag		private DoublyLinkedNode next;		// Link to next node		private DoublyLinkedNode prev;	// Link to previous node		private DoublyLinkedNode(T dataPortion)		{			this(dataPortion, null, null);			} // end constructor		private DoublyLinkedNode(T dataPortion, DoublyLinkedNode nextNode,				DoublyLinkedNode previousNode)		{			data = dataPortion;			next = nextNode;			prev = previousNode;		} // end constructor	} // end DoublyLinkedNode} // end DoublyLinkedBag