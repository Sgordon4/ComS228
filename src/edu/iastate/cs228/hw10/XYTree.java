package edu.iastate.cs228.hw10;/** * A class that implements an xy-tree. *  * @author Sean Gordon *  *  *  *  * NOTEs and REQUIREMENTs: *  * 0. Put your Firstname and Lastname after above empty author tag.  * Make sure that in both cases the first letter is uppercase and  * all others are composed of lowercase letters. *  * 1. You are allowed to create and use your own private helper  * methods. If you are introducing your own helper methods those * need to be private ONLY and properly documented as per Javadoc  * style. Provided constructors/methods declarations cannot be changed. *  * 2. No additional data fields can be introduced in the class below. * Or any other class provided as part of this HW. You are not allowed  * to change the case of the already existing data fields, or rename those. *  * 3. No custom classes of your own can be introduced or used.  *  * 4. Import statements are not allowed.  *  * 5. Fully qualified class names usage is not allowed. Exception is  * for levelOrderTraverse method ONLY, where you are allowed to use  * ONLY java.util.LinkedList class. *  * 6. You are allowed to reuse any part of the provided source codes  * or shown under lecture notes section of Canvas, which do not violate  * any of the requirements. *  * 7. If you have any additional questions PLEASE ask on Piazza Q/A  * platform, however, before posting a question PLEASE, first, search * the Q/A platform to see if the same question was not already asked  * and answered. PLEASE setup your notifications for both Canvas and  * Piazza so that you are updated, immediately, whenever there are any  * changes happen either on Canvas or Piazza Q/A platform. *  * 8. You need to provide implementation to all methods which have a  * comment //TODO in their body. In this HW there 3 of those, i.e., * addPoint, contains, and leverlOrderTraverse. For all of these methods  * there is no need to provide comments. Same, i.e., no comments, applies * also for all provided classes/interfaces, including their  * constructors/methods which you are not required to implement as part  * of this HW.    *  * 9.You can assume that x and y values of every Point will always be * int values. *  *  */public class XYTree<T extends java.awt.Point> implements TreeInterface<T>{	private BinaryNode<T> root;	public XYTree()	{		root = null;	}	public XYTree(T rootData)	{		if (rootData != null)			root = new BinaryNode<>(rootData);		else			throw new IllegalArgumentException();	}	public void addAllPoints(T[] entries)	{		if (entries == null || entries.length == 0)			throw new IllegalArgumentException();		for (T t : entries)			addPoint(t);	}	/**	 *	 * Adds a new point into the xy-tree if it does not 	 * exist in this tree. Check an example under Canvas.	 * Also, check the comment of levelOrderTraverse.	 * 	 */	public void addPoint(T anEntry)	{		if (anEntry == null)			throw new IllegalArgumentException();		if(root == null) {							//If there is no root...			root = new BinaryNode<>(anEntry);		// slap it in there			return;									// (and run to avoid the return slap)		}		BinaryNode<T> current = root;		int level = 0;					//Used to compare whether to check x or y cord		while(current != null) {					//Not ever triggered, may as well be a while(true)			if(current.getData().equals(anEntry))	//If this is a duplicate, exit immediately, duplicates make the time space continuum unstable				return;			if((level%2 == 0 && current.getData().x >= anEntry.x) || 	//If this is an even level, compare x cords					(level%2 == 1 && current.getData().y >= anEntry.y)) // else compare y			{				if(current.getLeftChild() == null) {					//If anEntry is small and there is no left child					current.setLeftChild(new BinaryNode<>(anEntry));	// make anEntry a left hand man (or woman, idk)					return;				}				current = current.getLeftChild();						//If there is a left child, select that one and continue			}			else {				if(current.getRightChild() == null) {					//If anEntry is big and there is no right child					current.setRightChild(new BinaryNode<>(anEntry));	// make anEntry a right hand apache attack helicopter					return;				}				current = current.getRightChild();						//If there is a right child, select that one and continue			}			level++;													//Check the other cord next		}	}	/**	 * Returns true if a point exists in this tree, 	 * otherwise false.	 * 	 */	public boolean contains(T anEntry)	{		if (anEntry == null)			throw new IllegalArgumentException();		return levelOrderTraverse().contains("(" + anEntry.x + ", " + anEntry.y + ")");	}	/**	 * Returns a list of points in level-order traversal. 	 * In this method you are allowed to use 	 * java.util.LinkedList class.	 * 	 * 	 * For example,	 * 	 * XYTree<Point> xy = new XYTree<>(); 	 * 	 * xy.addAllPoints(new Point[]{	 * 	new Point(5, 3), 	 *    new Point(5, 2), 	 *    new Point(10, 7), 	 *    new Point(9, 1), 	 *    new Point(6, 8), 	 *    new Point(6, 8), 	 *    new Point(10, 1)	 * });	 * System.out.println(xy.levelOrderTraverse());	 * 	 * would print	 * 	 * [(5, 3), (5, 2), (10, 7), (9, 1), (6, 8), (10, 1)]	 * 	 */	public java.util.LinkedList<String> levelOrderTraverse()	{		//There is more efficiency to be had here, but I value my time		java.util.LinkedList<BinaryNode<T>> list = new java.util.LinkedList<BinaryNode<T>>();		java.util.LinkedList<String> StrList = new java.util.LinkedList<String>();		BinaryNode<T> temp = null;				list.offer(root);		while (!list.isEmpty()) {			temp = list.pop();			if (temp.hasLeftChild())				list.offer(temp.getLeftChild());			if (temp.hasRightChild())				list.offer(temp.getRightChild());			StrList.add("("+temp.getData().x+", "+temp.getData().y+")");		}				return StrList;	}	@Override	@SuppressWarnings("unchecked")	public T getRootData()	{		if (isEmpty())			throw new RuntimeException("Empty Tree!");		else			return (T) root.getData().clone();	}	@Override	public boolean isEmpty()	{		return root == null;	}	@Override	public void clear()	{		root = null;	}	@Override	public int getHeight()	{		return root.getHeight();	}	@Override	public int getNumberOfNodes()	{		return root.getNumberOfNodes();	}}