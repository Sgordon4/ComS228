package edu.iastate.cs228.hw10;import java.util.LinkedList;import edu.iastate.cs228.hw09.BinaryNode;/** * A class that implements an xy-tree. *  * @author Sean Gordon *  *  *  *  * NOTEs and REQUIREMENTs: *  * 0. Put your Firstname and Lastname after above empty author tag.  * Make sure that in both cases the first letter is uppercase and  * all others are composed of lowercase letters. *  * 1. You are allowed to create and use your own private helper  * methods. If you are introducing your own helper methods those * need to be private ONLY and properly documented as per Javadoc  * style. Provided constructors/methods declarations cannot be changed. *  * 2. No additional data fields can be introduced in the class below. * Or any other class provided as part of this HW. You are not allowed  * to change the case of the already existing data fields, or rename those. *  * 3. No custom classes of your own can be introduced or used.  *  * 4. Import statements are not allowed.  *  * 5. Fully qualified class names usage is not allowed. Exception is  * for levelOrderTraverse method ONLY, where you are allowed to use  * ONLY java.util.LinkedList class. *  * 6. You are allowed to reuse any part of the provided source codes  * or shown under lecture notes section of Canvas, which do not violate  * any of the requirements. *  * 7. If you have any additional questions PLEASE ask on Piazza Q/A  * platform, however, before posting a question PLEASE, first, search * the Q/A platform to see if the same question was not already asked  * and answered. PLEASE setup your notifications for both Canvas and  * Piazza so that you are updated, immediately, whenever there are any  * changes happen either on Canvas or Piazza Q/A platform. *  * 8. You need to provide implementation to all methods which have a  * comment //TODO in their body. In this HW there 3 of those, i.e., * addPoint, contains, and leverlOrderTraverse. For all of these methods  * there is no need to provide comments. Same, i.e., no comments, applies * also for all provided classes/interfaces, including their  * constructors/methods which you are not required to implement as part  * of this HW.    *  * 9.You can assume that x and y values of every Point will always be * int values. *  *  */public class XYTree<T extends java.awt.Point> implements TreeInterface<T>{	private BinaryNode<T> root;	public XYTree()	{		root = null;	}	public XYTree(T rootData)	{		if (rootData != null)			root = new BinaryNode<>(rootData);		else			throw new IllegalArgumentException();	}	public void addAllPoints(T[] entries)	{		if (entries == null || entries.length == 0)			throw new IllegalArgumentException();		for (T t : entries)			addPoint(t);	}	/**	 *	 * Adds a new point into the xy-tree if it does not 	 * exist in this tree. Check an example under Canvas.	 * Also, check the comment of levelOrderTraverse.	 * 	 */	public void addPoint(T anEntry)	{		if (anEntry == null)			throw new IllegalArgumentException();		if(root == null) {			root = new BinaryNode<>(anEntry);			return;		}		BinaryNode<T> current = root;		int level = 0;		while(current != null) {			if(current.getData().equals(anEntry))				return;			if((level%2 == 0 && current.getData().x >= anEntry.x) || 					(level%2 == 1 && current.getData().y >= anEntry.y)) 			{				if(current.getLeftChild() == null) {					current.setLeftChild(new BinaryNode<>(anEntry));					return;				}				current = current.getLeftChild();			}			else {				if(current.getRightChild() == null) {					current.setRightChild(new BinaryNode<>(anEntry));					return;				}				current = current.getRightChild();			}			level++;			/*			switch(level%2) {			case 0:				if(current.getData().getX() >= anEntry.getX()) {					if(current.getLeftChild() == null) {						current.setLeftChild(new BinaryNode<>(anEntry));						return;					}					current = current.getLeftChild();				}				else {					if(current.getRightChild() == null) {						current.setRightChild(new BinaryNode<>(anEntry));						return;					}					current = current.getRightChild();				}				break;			case 1:				if(current.getData().getY() >= anEntry.getY()) {					if(current.getLeftChild() == null) {						current.setLeftChild(new BinaryNode<>(anEntry));						return;					}					current = current.getLeftChild();				}				else {					if(current.getRightChild() == null) {						current.setRightChild(new BinaryNode<>(anEntry));						return;					}					current = current.getRightChild();				}				break;			}			level++;			 */		}	}	/**	 * Returns true if a point exists in this tree, 	 * otherwise false.	 * 	 */	public boolean contains(T anEntry)	{		if (anEntry == null)			throw new IllegalArgumentException();		// TODO		return false;	}	/**	 * Returns a list of points in level-order traversal. 	 * In this method you are allowed to use 	 * java.util.LinkedList class.	 * 	 * 	 * For example,	 * 	 * XYTree<Point> xy = new XYTree<>(); 	 * 	 * xy.addAllPoints(new Point[]{	 * 	new Point(5, 3), 	 *    new Point(5, 2), 	 *    new Point(10, 7), 	 *    new Point(9, 1), 	 *    new Point(6, 8), 	 *    new Point(6, 8), 	 *    new Point(10, 1)	 * });	 * System.out.println(xy.levelOrderTraverse());	 * 	 * would print	 * 	 * [(5, 3), (5, 2), (10, 7), (9, 1), (6, 8), (10, 1)]	 * 	 */	public java.util.LinkedList<String> levelOrderTraverse()	{		java.util.LinkedList<BinaryNode<T>> list = new java.util.LinkedList<BinaryNode<T>>();		BinaryNode<T> temp = null;				list.offer(root);		while (!list.isEmpty()) {			temp = list.pop();			if (temp.hasLeftChild())				list.offer(temp.getLeftChild());			if (temp.hasRightChild())				list.offer(temp.getRightChild());			System.out.print(temp.getData() + " ");		}				return null;	}	/*	public void iterativeLevelorderTraverse()	{		LinkedList<BinaryNode<T>> nodeQueue = new LinkedList<>();		BinaryNode<T> temp = null;		nodeQueue.offer(root);		while (!nodeQueue.isEmpty()) {			temp = nodeQueue.pop();			if (temp.hasLeftChild())				nodeQueue.offer(temp.getLeftChild());			if (temp.hasRightChild())				nodeQueue.offer(temp.getRightChild());			System.out.print(temp.getData() + " ");		}		return;	}	 */	@Override	@SuppressWarnings("unchecked")	public T getRootData()	{		if (isEmpty())			throw new RuntimeException("Empty Tree!");		else			return (T) root.getData().clone();	}	@Override	public boolean isEmpty()	{		return root == null;	}	@Override	public void clear()	{		root = null;	}	@Override	public int getHeight()	{		return root.getHeight();	}	@Override	public int getNumberOfNodes()	{		return root.getNumberOfNodes();	}}